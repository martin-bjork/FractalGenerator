#pragma kernel Clear
#pragma kernel CalculateEscapeTime
#pragma kernel ColourByEscapeTime

#include "ComplexNumbers.cginc"

RWTexture2D<float4> ResultTexture;
RWStructuredBuffer<int> EscapeTimeBuffer;
int MaxIterations;
float2 LowerLeft;
float Scale;

uint FlattenIndex(uint3 id) {
    uint width;
    uint height;
    ResultTexture.GetDimensions(width, height);
    return id.y * width + id.x;
}

bool IsOnScreen(uint3 id) {
    uint width;
    uint height;
    ResultTexture.GetDimensions(width, height);
    return id.x < width && id.y < height;
}

Complex GetComplexForPixel(uint3 id) {
    float2 scaled = float2(id.x, id.y) * Scale;
    float2 translated = scaled + LowerLeft;
    return CreateComplex(translated.x, translated.y);
}

[numthreads(8,8,1)]
void Clear (uint3 id : SV_DispatchThreadID) {
    uint index = FlattenIndex(id);
    EscapeTimeBuffer[index] = 0;
}

[numthreads(8,8,1)]
void CalculateEscapeTime (uint3 id : SV_DispatchThreadID) {
   if (!IsOnScreen(id)) {
       return;
   }
    uint index = FlattenIndex(id);

    Complex z = CreateComplex(0, 0);
    Complex c = GetComplexForPixel(id);
    int iterations = 0;

    for (int i = 0; i < MaxIterations; i++) {
        z = Multiply(z, z);
        z = Add(z, c);
        if (SquareMagnitude(z) > 4) {
            break;
        }
        iterations++;
    }

    EscapeTimeBuffer[index] = iterations;
}

[numthreads(8,8,1)]
void ColourByEscapeTime (uint3 id : SV_DispatchThreadID) {
    uint index = FlattenIndex(id);
    int escapeTime = EscapeTimeBuffer[index];
    float fraction = ((float)escapeTime + 1.0f) / (float)MaxIterations;
    ResultTexture[id.xy] = escapeTime < MaxIterations ? float4(fraction, fraction, fraction, 1) : float4(0, 0, 0, 0);
}
